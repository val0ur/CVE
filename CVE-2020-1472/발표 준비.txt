Presentation Sheet

Reference
 - github.com/SecuraBV/CVE-2020-1472




* CVE-2020-1472 / Zerologon 

 통칭 Zerologon이라고 불리며,
 공격자가 Domain Controller에 대한 TCP  연결을 수립할 수 있다면 
 Active Directory 상의 모든 계정의 PW를 초기화 할 수 있는 취약점입니다. 

 ! Active Directory란 Windows Server에서 제공하는 Directory Service로 
 ! Directory Service는 
  중앙 서버에 공통된 데이터베이스를 생성하여 
  각 서버와 클라이언트는 해당 데이터베이스를 공유하여 Object를 검색하고 
  중앙에서 사용자 인증 및 권한 부여 처리가 가능하도록 처리해주는 서비스 입니다.  

 Domain Controller DC 는 Active Directory를 운영하는 서버 컴퓨터 입니다. 
 
 [이미지] | AD 1.PNG
 > 이런식으로 DB를 두고 계정들에 대한 인증을 수행한 이후에 
    정상적으로 서비스를 이용할 수 있도록 해줍니다. 

----------------------------------------------------------------------------------------

* 개요 

 Domain Controller에서 Domain Client를 인증할 때 Netlogon Protocol을 사용한다. 

 [이미지] | netlogon 인증 과정.PNG
 
 1. Client와 Server는 Random 8-Byte nonce 값을 교환하고 각각 Client Challenge, Server Challenge 라고 한다. 
 2. KDF(Key Derivation Function) 키 유도 함수를 사용하여 Session Key를 생성합니다. 
    > Session Key = KDF(Client PW Hash + Client Challenge + Server Challenge)
 3. Client는 Session Key를 이용해 Client Credential을 생성 후 서버로 보내줍니다.
 4. Server에서 Client가 보낸 Client Credential과 Server에서 계산한 Client Credential이 같으면 
    정상 Client로 간주하고 Server Credential을 보내줍니다. 
 5. Client는 만들어진 Session Key를 가지고 이 Credential을 signed + sealed하여 권한이 필요한 작업을 수행합니다.
 > 4의 인증 수립 후 Message들에 대해 sign +seal을 할지 여부는 결정할 수 있습니다. 

 위 과정에서 Client와 Server는 Credential Value를 만들기 위해 
 NlComputeCredentials 함수를 사용하는데 암호화 과정에서 IV 값이 0으로 고정되어 있어 발생하는 취약점입니다. 
 
 공격자는 이점을 이용해서 Client Credential을 0으로 만들 수 있고 정상적인 Client로 인증 받은 후 
 계정의 PW를 초기화 시킬 수 있습니다!
 
----------------------------------------------------------------------------------------

 * 세부사항 

 NlComputeCredentials는 8-Byte Input(Server 입장에서는 Client Challenge)를 받아 암호화 하여 
 8-Byte의 Credential을 만듭니다. 

 해당 함수는 2DES or AES 암호화를 지원하는데 최근 대부분의 Domain Server는 AES 방식만을 사용합니다. 

 //AES는 16바이트의 Plain text를 16바이트의 Cipher text로 암호화 하는 과정에서
   16바이트 보다 작은 Input을 처리하는 방식들이 존재합니다. 

 해당 암호화 과정에서는 NlInitializeCNG 함수를 통해 AES-CFB8을 사용한다는 것을 알 수 있습니다.  

 [이미지] | NlInitializeCNG.PNG

 # AES-CFB8 
 
 [이미지] | AES-CFB8.PNG 
 
 AES-CFB8은 16 바이트의 IV값을 가지고 
 IV에 Session Key를 인자로 AES를 수행하고 나온 결과값의 첫 바이트와 Plain Text의 첫 바이트를 
 XOR 하여 Cipher Text에 저장합니다. 
 이를 반복해서 모든 Plain Text를 Cipher Text로 암호화해줍니다. 

 IV값이 랜덤 값일 경우에는 평문을 안전하게 암호화 할 수 있지만 
 NlComputeCredentials 함수에서는 IV값을 0으로 사용합니다. 

 그렇다면 IV값이 0이면 어떤 문제가 있는 걸까요?

 [이미지] | IV=0일 때 문제점.PNG

 IV값을 Session Key로 AES를 수행한 후 나온 결과값의 첫 바이트가 0이라면 
 Plain Text도 0이고 Cipher Text도 0인 경우가 생긴다. 

 공격자 입장에서는 Session Key를 몰라도 암호화한 결과값의 첫 바이트가 0이 되는 경우만 생기면
 Cipher Text도 0이 되므로 이 취약점을 이용할 수 있다. 

 인증은 NetServerAuthenticate3 함수에서 수행하며 
 NlComputeCredentials를 통해 Server가 계산한 ClientCredential(MADE)과 
 Client가 보낸 ClientCredential(GOT)가 동일하다면 인증을 허용해줍니다. 

----------------------------------------------------------------------------------------

 * Zerologon을 활용한 Exploit
 
 1. Spoofing the client credential 
 
 NetServerReqChallenge 함수를 호출하여 Challenge 교환 후  
 Client는 Server의 NetServerAuthenticate3 함수를 호출하여 인증을 시도합니다. 
 해당 함수내 ClientCredential이라는 변수가 있으며 이것이 Server에서 비교할 Client Credential 값이 됩니다. 

 ClientCredential 값은 임의로 설정이 가능하고 취약 버전에서는 Server상에서 검증이나 잘못된 로그인 시도에 대한
 제재가 없기 때문에 Brute Forcing이 가능합니다. 

 256회의 trial만 있으면 가능하기 때문에 2~3초 정도 밖에 걸리지 않습니다. 

 2. Disabling signing and sealing 

 1번을 수행하며 Client Credential을  Spoofing 했지만 Session Key값이 뭔지는 알 수 없기 때문에 
 Message들을 sign + seal 을 비활성화 해줍니다. 
 > NetServerAuthenticate3을 호출할 때 Flag 값을 통해 비활성화 할 수 있습니다.
 [+] docs.microsoft.com/en-us/openspecs/windows_protocols/ms-nrpc/5805bc9f-e4c9-4c8a-b191-3c3a7de7eeed

 3. Spoofing a call
 
 2번에서 Call Encryption을 비활성화 시켰더라도 모든 RPC Call은 Authenticator value 값을 포함하고 있어야합니다. 
 이 값은 ComputeNetlogonCredential 함수를 호출할 때 필요한 인자인 ClientStoredCredential을 계산하는데 사용됩니다.
 
 ClientStoredCredential을 위해 필요한 Authenticator 값은 Credential + Timstamp로 
 Credential은 공격자가 서버에 제공한 ClientCredential과 동일한 값으로 \x00*8로 설정합니다. 

 TimeStamp는 현재 시간 값과 일치하는지 검증하지 않으므로 간단히 0으로 설정해주면됩니다. (\x00*4)

 4. Changing a computer's AD PW

 위의 과정들을 이용하면 어떤 Computer로든지 인증된 Netlogon Call을 수행할 수 있습니다. 
 기존 설정된 Computer 계정의 AD PW를 변경해보도록 하겠습니다.

 NetServerPasswrodSet2 함수는 Client에서 새 Computer Password를 설정하는데 사용되는 함수로 
 이 함수를 이용합니다. 
 설정할 암호 자체는 Hash 돼있지 않지만 Session Key로 암호화 돼야하기 때문에 1번 과정과 같이 
 0으로 설정해주면 됩니다. 

 Netlogon 프로토콜의 Plain Text Password 구조는 516바이트 크기로 구성되며 마지막 4 바이트는 PW의 길이를 나타냅니다.
 즉, 516 바이트를 모두 0으로 채우면 길이가 0인 Empty PW로 취급됩니다. 
 
 PW 변경 후에는 공격없이 정상적인 사용자로서 권한있는 작업을 수행할 수 있습니다. 

 
 
 



 











 